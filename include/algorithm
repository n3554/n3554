#pragma once

#include <detail/config.hpp>
#include <execution_policy>
#include_next <algorithm>
#include <iostream>
#include <thrust/execution_policy.h>
#include <thrust/logical.h>
#include <thrust/for_each.h>

namespace std
{


template<class InputIterator, class Predicate>
bool __all_of(const sequential_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::all_of(thrust::seq, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __all_of(const parallel_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::all_of(thrust::device, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __all_of(const execution_policy &exec, InputIterator first, InputIterator last, Predicate pred)
{
  bool result = false;

  switch(__which(exec))
  {
    case 0:
      result = __all_of(__union(exec).seq, first, last, pred);
      break;

    case 1:
      result = __all_of(__union(exec).par, first, last, pred);
      break;
  }

  return result;
}


template<class InputIterator, class Predicate>
bool __any_of(const sequential_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::any_of(thrust::seq, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __any_of(const parallel_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::any_of(thrust::device, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __any_of(const execution_policy &exec, InputIterator first, InputIterator last, Predicate pred)
{
  bool result = false;

  switch(__which(exec))
  {
    case 0:
      result = __any_of(__union(exec).seq, first, last, pred);
      break;

    case 1:
      result = __any_of(__union(exec).par, first, last, pred);
      break;
  }

  return result;
}


template<class InputIterator, class Predicate>
bool __none_of(const sequential_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::none_of(thrust::seq, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __none_of(const parallel_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::none_of(thrust::device, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __none_of(const execution_policy &exec, InputIterator first, InputIterator last, Predicate pred)
{
  bool result = false;

  switch(__which(exec))
  {
    case 0:
      result = __none_of(__union(exec).seq, first, last, pred);
      break;

    case 1:
      result = __none_of(__union(exec).par, first, last, pred);
      break;
  }

  return result;
}


template<typename InputIterator, typename Function>
InputIterator __for_each(const sequential_execution_policy &, InputIterator first, InputIterator last, Function f)
{
  return thrust::for_each(thrust::seq, first, last, f);
}


template<typename InputIterator, typename Function>
InputIterator __for_each(const parallel_execution_policy &, InputIterator first, InputIterator last, Function f)
{
  return thrust::for_each(thrust::device, first, last, f);
}


template<typename InputIterator, typename Function>
InputIterator __for_each(const execution_policy &exec, InputIterator first, InputIterator last, Function f)
{
  switch(__which(exec))
  {
    case 0:
      first = __for_each(__union(exec).seq, first, last, f);
      break;

    case 1:
      first = __for_each(__union(exec).par, first, last, f);
      break;
  }

  return first;
}


template<class ExecutionPolicy,
         class InputIterator, class Predicate>
typename std::enable_if<
  std::is_execution_policy<
    typename std::decay<ExecutionPolicy>::type
  >::value,
  bool
>::type
all_of(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Predicate pred)
{
  return __all_of(exec, first, last, pred);
}


template<class ExecutionPolicy,
         class InputIterator, class Predicate>
typename std::enable_if<
  std::is_execution_policy<
    typename std::decay<ExecutionPolicy>::type
  >::value,
  bool
>::type
any_of(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Predicate pred)
{
  return __any_of(exec, first, last, pred);
}


template<class ExecutionPolicy,
         class InputIterator, class Predicate>
typename std::enable_if<
  std::is_execution_policy<
    typename std::decay<ExecutionPolicy>::type
  >::value,
  bool
>::type
none_of(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Predicate pred)
{
  return __none_of(exec, first, last, pred);
}


template<typename ExecutionPolicy, typename InputIterator, typename Function>
typename std::enable_if<
  std::is_execution_policy<
    typename std::decay<ExecutionPolicy>::type
  >::value,
  InputIterator
>::type
for_each(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Function f)
{
  return __for_each(exec, first, last, f);
}


}

